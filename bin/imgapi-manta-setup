#!/usr/bin/env node
/**
 * -*- mode: js -*-
 *
 * Copyright (c) 2013, Joyent, Inc. All rights reserved.
 *
 * Ensure that the imgapi service has an SSH key in SAPI, and added to the
 * admin user in UFDS.
 *
 * If not (i.e. this is a first run for the first imgapi zone), then create
 * one and load it into SAPI and UFDS. The config-agent will handle
 * installing that ssh key in all imgapi zones.
 *
 * This SSH key is used so IMGAPI can access Manta for file storage (if
 * configured to use Manta).
 */


var p = console.log;
var trace = process.env.TRACE ? p : function () {};

var format = require('util').format;
var exec = require('child_process').exec;
var path = require('path');
var fs = require('fs');
var os = require('os');

var once = require('once');
var assert = require('assert-plus');
var dashdash = require('dashdash');
var async = require('async');
var sdcClients = require('sdc-clients');
var bunyan = require('bunyan');


//---- globals

var log; // set in `main()`

var USAGE = (
    'Setup the imgapi service in this SmartDataCenter to use a given manta\n'
    + 'for image storage. This will do the appropriate setup for all\n'
    + 'instances of imgapi in this DC. This is also re-runnable if it fails\n'
    + 'part way.\n'
    + '\n'
    + 'Usage:\n'
    + '    imgapi-manta-setup [OPTIONS] | bunyan\n'
    + '\n'
    + 'Options:\n'
    + '%s\n'
    + '\n'
    + 'The config options will be pulled from "/opt/smartdc/etc/zoneconfig"\n'
    + 'if not specified.'
);

var ZONECONFIG_PATH = '/opt/smartdc/etc/zoneconfig';
if (os.platform() === 'darwin') {
    ZONECONFIG_PATH = '/var/tmp/zoneconfig';
}

var CONFIG_VARS = [
    'SAPI_ADMIN_IPS',
    'VMAPI_ADMIN_IPS',
    'UFDS_ADMIN_UUID',
    'UFDS_ADMIN_IPS',
    'UFDS_LDAP_ROOT_DN',
    'UFDS_LDAP_ROOT_PW'
];



//---- internal support routines

function fatal(msg, exitCode) {
    console.error('imgapi-manta-setup: error: %s', msg);
    if (msg.stack) {
        console.error(msg.stack);
    }
    process.exit(exitCode);
}

function loadConfig(opts, callback) {
    assert.object(opts, 'opts');
    var config = {};

    // Note: This manual parsing of zoneconfig could blow up if it is using
    // bash-special processing.
    var lines = fs.readFileSync(ZONECONFIG_PATH, 'utf8').split(/\n/g);
    var zoneconfig = {};
    lines.forEach(function (line) {
        line = line.trim();
        if (!line.length)
            return;
        /* JSSTYLED */
        var match = /^(\w+)='(.*?)'$/.exec(line);
        if (!match) {
            console.warn('unexpected line in "%s": "%s"',
                ZONECONFIG_PATH, line);
            return;
        }
        zoneconfig[match[1]] = match[2];
    });

    for (var i = 0; i < CONFIG_VARS.length; i++) {
        var name = CONFIG_VARS[i];
        var nameLc = name.toLowerCase();
        if (opts[nameLc] !== undefined) {
            config[name] = opts[nameLc];
        } else if (zoneconfig[name] !== undefined) {
            config[name] = zoneconfig[name];
        } else {
            return callback(new Error(format(
                'could not find config for "%s" in "%s" or in given options',
                name, ZONECONFIG_PATH)));
        }
    }

    // 'UFDS_ADMIN_IP' is the first of UFDS_ADMIN_IPS
    config.UFDS_ADMIN_IP = (opts.ufds_admin_ip ||
        config.UFDS_ADMIN_IPS.split(',')[0].trim());
    // 'SAPI_ADMIN_IP' is the first of SAPI_ADMIN_IPS
    config.SAPI_ADMIN_IP = (opts.sapi_admin_ip ||
        config.SAPI_ADMIN_IPS.split(',')[0].trim());
    // 'VMAPI_ADMIN_IP' is the first of VMAPI_ADMIN_IPS
    config.VMAPI_ADMIN_IP = (opts.vmapi_admin_ip ||
        config.VMAPI_ADMIN_IPS.split(',')[0].trim());

    config.manta_url = opts.manta_url;

    callback(null, config);
}


function getMantaUrl(config, callback) {
    assert.object(config, 'config');
    assert.func(callback, 'callback');

    if (config.manta_url !== 'FIRST-LB') {
        return callback(null, config.manta_url);
    }

    var sapi = new sdcClients.SAPI({
        url: 'http://' + config.SAPI_ADMIN_IP,
        log: log,
        agent: false
    });
    var vmapi = new sdcClients.VMAPI({
        url: 'http://' + config.VMAPI_ADMIN_IP,
        log: log,
        agent: false
    });

    sapi.listApplications({name: 'manta'}, function (aErr, apps) {
        if (aErr)
            return callback(aErr);
        if (apps.length === 0) {
            return callback(new Error('no "manta" application found'));
        }
        var app = apps[0];
        var mantaOwner = app.owner_uuid;  // should be the poseidon UUID

        // TODO: should perhaps use the app.metadata.MANTA_SERVICE
        // (e.g. 'MANTA_SERVICE': 'manta.bh1.joyent.us'), but at least in
        // staging that doesn't resolve yet. For now we'll use the first
        // LB IP.
        var search = {
            owner_uuid: mantaOwner,
            'tag.manta_role': 'loadbalancer'
        };
        vmapi.listVms(search, function (vErr, vms) {
            if (vErr)
                return callback(vErr);
            if (vms.length === 0) {
                return callback(new Error(
                    'no manta "loadbalancer" VMs were found'));
            }
            var nics = vms[0].nics;
            var ip;
            for (var i = 0; i < nics.length; i++) {
                if (nics[i].nic_tag === 'external') {
                    ip = nics[i].ip;
                    break;
                }
            }
            if (!ip) {
                return callback(new Error(
                    'no external IP on the first Manta LB'));
            }
            var mantaUrl = 'https://' + ip;
            callback(null, mantaUrl);
        });
    });
}


function getUfdsClient(config, sdcApp, callback) {
    assert.object(config, 'config');
    assert.object(sdcApp, 'sdcApp');
    assert.func(callback, 'callback');
    log.info('get *master* ufdsClient');

    // Get the URL for the *master* UFDS, which might not be local.
    var ufdsIsMaster = (sdcApp.metadata.ufds_is_master === 'true');
    var ufdsIp;
    if (ufdsIsMaster) {
        ufdsIp = sdcApp.metadata.ufds_admin_ips.split(',')[0];
    } else {
        ufdsIp = sdcApp.metadata.ufds_remote_ip;
    }
    if (!ufdsIp) {
        callback(new Error('could not find master UFDS IP (in '
            + '"ufds_admin_ips" or "ufds_remote_ip")'));
        return;
    }
    var ufdsUrl = 'ldaps://' + ufdsIp;

    var options = {
        url: ufdsUrl,
        bindDN: config.UFDS_LDAP_ROOT_DN,
        bindPassword: config.UFDS_LDAP_ROOT_PW,
        log: log
    };
    var ufds = new sdcClients.UFDS(options);

    var callback_ = once(callback);
    ufds.on('ready', function () {
        log.info('ufds client is ready');
        callback_(null, ufds);
    });
    ufds.on('timeout', function () {
        log.error('ufds client timeout');
    });
    ufds.on('error', function (connErr) {
        log.error('ufds client connect error');
        callback_(connErr);
    });
}


function getAdminUser(config, ufdsClient, callback) {
    ufdsClient.getUser(config.UFDS_ADMIN_UUID, function (uErr, user) {
        if (uErr)
            return callback(uErr);
        log.info({user: user}, 'got admin user');
        callback(null, user);
    });
}


/**
 * Generate an ssh key pair and return the content.
 *
 * This is adapted from manta-deployment.git/lib/ssh.js
 */
function generateKey(callback) {
    assert.func(callback, 'callback');

    var privPath = format('/var/tmp/imgapi.%s.id_rsa', process.pid);
    var pubPath = privPath + '.pub';
    var key = {};

    async.series([
        function (next) {
            var cmd = format(
                '/usr/bin/ssh-keygen -t rsa -f %s -N "" -C imgapi', privPath);
            log.info({cmd: cmd}, 'generating SSH key');
            exec(cmd, function (err, stdout, stderr) {
                if (err) {
                    log.error(err, 'failed to generate SSH key');
                    return (next(err));
                }
                next();
            });
        },
        function (next) {
            log.info('reading private key from %s', privPath);
            fs.readFile(privPath, 'ascii', function (err, contents) {
                if (err) {
                    log.error(err, 'failed to read private key %s', privPath);
                    return (next(err));
                }
                key.priv = contents.trim();
                next(null);
            });
        },
        function (next) {
            log.info('reading public key from %s', pubPath);
            fs.readFile(pubPath, 'ascii', function (err, contents) {
                    if (err) {
                        log.error(err, 'failed to read public key %s', pubPath);
                        return (next(err));
                    }
                    key.pub = contents.trim();
                    next(null);
            });
        },
        function (next) {
            var cmd = format('/usr/bin/ssh-keygen -l -f %s | ' +
                'awk \'{print $2}\'', privPath);
            log.info({cmd: cmd}, 'reading key signature');
            exec(cmd, function (err, stdout, stderr) {
                if (err) {
                    log.error(err, 'failed to read key signature');
                    return (next(err));
                }
                key.id = stdout.trim();
                next(null);
            });
        }
    ], function (err) {
        async.forEach(
            [privPath, pubPath],
            fs.unlink,
            function (uErr) {
                if (uErr) {
                    log.warn(uErr, 'could not remove tmp key files: %s, %s',
                        privPath, pubPath);
                }
                callback(err, key);
            }
        );
    });
}


function getSdcApp(config, callback) {
    var sapi = new sdcClients.SAPI({
        url: 'http://' + config.SAPI_ADMIN_IP,
        log: log,
        agent: false
    });
    sapi.listApplications({name: 'sdc'}, function (aErr, apps) {
        if (aErr)
            return next(aErr);
        callback(null, apps[0]);
    });
}


/**
 * Ensure there is a key (pub and priv) in SAPI for the imgapi service. If
 * not, create it and add it.  This also include other updates: the imgapi
 * config file, the ~/.mantaprofile file in the imgapi zones.
 *
 * ...
 * @param callback {Function} `function (err, key)`
 */
function ensureKeyInSapi(config, sdcApp, mantaUrl, adminUser, callback) {
    var sapi = new sdcClients.SAPI({
        url: 'http://' + config.SAPI_ADMIN_IP,
        log: log,
        agent: false
    });

    var svc, key;
    async.series([
        function (next) {
            log.info('check whether SAPI already has an imgapi key');
            var searchOpts = {name: 'imgapi', application_uuid: sdcApp.uuid};
            sapi.listServices(searchOpts, function (sErr, svcs) {
                if (sErr)
                    return next(sErr);
                svc = svcs[0];
                if (!svc.manifests.ssh_public_key ||
                    !svc.manifests.ssh_private_key ||
                    !svc.manifests.mantaprofile ||
                    !svc.metadata.IMGAPI_PUBLIC_KEY ||
                    !svc.metadata.IMGAPI_PRIVATE_KEY ||
                    !svc.metadata.IMGAPI_KEY_ID)
                {
                    return next();
                }
                // Check if the 'imgapi' manifest (i.e. the imgapi.config.json
                // file) is setup for manta.
                sapi.getManifest(svc.manifests.imgapi, function (gErr, m) {
                    if (gErr)
                        return next(gErr);
                    try {
                        var template = JSON.parse(m.template);
                    } catch (e) {
                        return next(new Error(format(
                            'could not JSON.parse imgapi manifest %s '
                            + 'template: "%s"',
                            svc.manifests.imgapi, m.template)));
                    }
                    if (!template.storage.manta) {
                        // TODO: could verify that settings match the key
                        next();  // need to update things
                    } else {
                        log.info('imgapi key already setup in SAPI');
                        key = {
                            pub: svc.metadata.IMGAPI_PUBLIC_KEY,
                            priv: svc.metadata.IMGAPI_PRIVATE_KEY,
                            id: svc.metadata.IMGAPI_KEY_ID
                        };
                        next(true); // signal to exit early, everything is good
                    }
                });
            });
        },
        function (next) {
            log.info('generate a new key');
            generateKey(function (kErr, key_) {
                if (kErr)
                    return next(kErr);
                key = key_;
                log.info({key: key}, 'generated key');
                next();
            });
        },
        function (next) {
            var md = {
                IMGAPI_PRIVATE_KEY: key.priv,
                IMGAPI_PUBLIC_KEY: key.pub,
                IMGAPI_KEY_ID: key.id
            };
            sapi.updateService(svc.uuid, {metadata: md}, function (uErr) {
                if (uErr)
                    return (next(uErr));
                log.info('metadata added to imgapi service');
                next();
            });
        },
        function (next) {
            var oldUuid = svc.manifests.ssh_public_key;
            var data = {
                name: 'ssh_public_key',
                template: '{{IMGAPI_PUBLIC_KEY}}',
                path: '/root/.ssh/id_rsa.pub'
            };
            sapi.createManifest(data, function (mErr, manifest) {
                if (mErr)
                    return next(mErr);
                log.info({manifest: manifest}, 'pub key manifest created');
                var update = {
                    manifests: {
                        ssh_public_key: manifest.uuid
                    }
                };
                sapi.updateService(svc.uuid, update, function (uErr) {
                    if (uErr)
                        return next(uErr);
                    log.info('pub key manifest added to imgapi service');
                    if (oldUuid) {
                        log.info('delete old pub key manifest:', oldUuid);
                        sapi.deleteManifest(oldUuid, next);
                    } else {
                        next();
                    }
                });
            });
        },
        function (next) {
            var oldUuid = svc.manifests.ssh_private_key;
            var data = {
                name: 'ssh_private_key',
                template: '{{IMGAPI_PRIVATE_KEY}}',
                path: '/root/.ssh/id_rsa'
            };
            sapi.createManifest(data, function (mErr, manifest) {
                if (mErr)
                    return next(mErr);
                log.info({manifest: manifest}, 'priv key manifest created');
                var update = {
                    manifests: {
                        ssh_private_key: manifest.uuid
                    }
                };
                sapi.updateService(svc.uuid, update, function (uErr) {
                    if (uErr)
                        return next(uErr);
                    log.info('priv key manifest added to imgapi service');
                    if (oldUuid) {
                        log.info('delete old priv key manifest:', oldUuid);
                        sapi.deleteManifest(oldUuid, next);
                    } else {
                        next();
                    }
                });
            });
        },
        function (next) {
            // Add the 'storage.manta' section to the imgapi config.
            sapi.getManifest(svc.manifests.imgapi, function (gErr, oldMan) {
                if (gErr)
                    return next(gErr);
                try {
                    var template = JSON.parse(oldMan.template);
                } catch (e) {
                    return next(new Error(format(
                        'could not JSON.parse imgapi manifest %s '
                        + 'template: "%s"',
                        svc.manifests.imgapi, oldMan.template)));
                }
                template.storage.manta = {
                    url: mantaUrl,
                    user: adminUser.login,
                    key: '/root/.ssh/id_rsa',
                    keyId: key.id
                };
                var newMan = {
                    name: oldMan.name,
                    path: oldMan.path,
                    template: JSON.stringify(template, null, 2)
                };
                sapi.createManifest(newMan, function (mErr, manifest) {
                    if (mErr)
                        return next(mErr);
                    log.info({manifest: manifest},
                        'new imgapi config manifest created');
                    var update = {
                        manifests: {
                            imgapi: manifest.uuid
                        }
                    };
                    var oldManifestUuid = svc.manifests.imgapi;
                    sapi.updateService(svc.uuid, update, function (uErr) {
                        if (uErr)
                            return next(uErr);
                        log.info('config manifest added to imgapi service');
                        sapi.deleteManifest(oldManifestUuid, function (dErr) {
                            if (dErr)
                                return next(dErr);
                            log.info('deleted old "imgapi" manifest: %s',
                                oldManifestUuid);
                            next();
                        });
                    });
                });
            });
        },
        function (next) {
            // Create a '~/.mantaprofile' to setup for using the node-manta
            // tools in the imgapi zones.
            var oldUuid = svc.manifests.mantaprofile;
            var data = {
                name: 'mantaprofile',
                template: (
                    format('export MANTA_USER=%s\n', adminUser.login)
                    + format('export MANTA_URL=%s\n', mantaUrl)
                    + format('export MANTA_KEY_ID=%s\n', key.id)
                ),
                path: '/root/.mantaprofile'
            };
            sapi.createManifest(data, function (mErr, manifest) {
                if (mErr)
                    return next(mErr);
                log.info({manifest: manifest}, 'mantaprofile manifest created');
                var update = {
                    manifests: {
                        mantaprofile: manifest.uuid
                    }
                };
                sapi.updateService(svc.uuid, update, function (uErr) {
                    if (uErr)
                        return next(uErr);
                    log.info('mantaprofile manifest added to imgapi service');
                    if (oldUuid) {
                        log.info('delete old mantaprofile manifest:', oldUuid);
                        sapi.deleteManifest(oldUuid, next);
                    } else {
                        next();
                    }
                });
            });
        }

    ], function (err) {
        if (err === true) {
            // This is the signal that we are done processing early, without
            // an error.
            callback(null, key);
        } else if (err) {
            callback(err);
        } else {
            callback(null, key);
        }
    });
}


function ensureKeyOnAdminUser(config, ufdsClient, adminUser, key, sdcApp,
                              callback) {
    assert.object(config, 'config');
    assert.object(ufdsClient, 'ufdsClient');
    assert.object(adminUser, 'adminUser');
    assert.object(key, 'key');
    assert.object(sdcApp, 'sdcApp');
    assert.func(callback, 'callback');
    log.info('ensure admin user has the imgapi key');

    function deleteKeyIfExists(user, name, next) {
        log.info('check for existing key name "%s" to delete', name);
        ufdsClient.getKey(user, name, function (gErr, keyToDel) {
            if (gErr && gErr.statusCode === 404) {
                next();
            } else if (gErr) {
                next(gErr);
            } else {
                log.info({keyToDel: keyToDel},
                    'deleting existing sdckey with same name');
                ufdsClient.deleteKey(user, keyToDel, next);
            }
        });
    }

    var sdcKey = {
        name: format('%s imgapi', sdcApp.metadata.datacenter_name),
        openssh: key.pub
    };
    deleteKeyIfExists(adminUser, sdcKey.name, function (dErr) {
        if (dErr)
            return callback(dErr);
        ufdsClient.addKey(adminUser, sdcKey, function (aErr, addedKey) {
            if (aErr)
                return callback(aErr);
            log.info({addedKey: addedKey},
                'added sdckey to admin user in UFDS');
            callback();
        });
    });
}



//---- mainline

var OPTIONS = [
    {
        names: ['help', 'h'],
        type: 'bool',
        help: 'Print this help and exit.'
    },
    {
        names: ['manta-url'],
        type: 'string',
        help: 'The URL at which IMGAPI should access Manta. Required. Use '
          + 'the special value "FIRST-LB" to hack for development: the first '
          + 'Manta load balancer external IP will be used.'
    },
    {
        names: ['sapi-admin-ip'],
        type: 'string',
        env: 'SAPI_ADMIN_IP'
    },
    {
        names: ['ufds-admin-uuid'],
        type: 'string',
        env: 'UFDS_ADMIN_UUID'
    },
    {
        names: ['ufds-admin-ip'],
        type: 'string',
        env: 'UFDS_ADMIN_IP'
    },
    {
        names: ['ufds-ldap-root-dn'],
        type: 'string',
        env: 'UFDS_LDAP_ROOT_DN'
    },
    {
        names: ['ufds-ldap-root-pw'],
        type: 'string',
        env: 'UFDS_LDAP_ROOT_PW'
    }
];

function main() {
    log = bunyan.createLogger({    // intentionally global
        name: 'imgapi-manta-setup',
        src: true,
        serializers: bunyan.stdSerializers
    });

    var parser = dashdash.createParser({options: OPTIONS});
    try {
        var opts = parser.parse(process.argv);
    } catch (e) {
        fatal(e.message, 1);
    }
    if (opts.help) {
        p(USAGE, parser.help({includeEnv: true}).trimRight());
        process.exit(0);
    }
    trace('opts', opts);
    if (!opts.manta_url) {
        fatal('no Manta URL specified (use "--manta-url=" option)', 1);
    }

    var config;
    var ufdsClient;
    var adminUser;
    var mantaUrl;
    var key;
    var sdcApp;

    async.series([
        function (next) {
            loadConfig(opts, function (cErr, config_) {
                config = config_;
                log.info({config: config}, 'loaded config');
                next(cErr);
            });
        },

        function (next) {
            getMantaUrl(config, function (mErr, mantaUrl_) {
                mantaUrl = mantaUrl_;
                log.info({mantaUrl: mantaUrl}, 'mantaUrl');
                next(mErr);
            });
        },

        function (next) {
            getSdcApp(config, function (err, sdcApp_) {
                sdcApp = sdcApp_;
                next(err);
            });
        },

        function (next) {
            getUfdsClient(config, sdcApp, function (err, ufdsClient_) {
                ufdsClient = ufdsClient_;
                next(err);
            });
        },

        function (next) {
            getAdminUser(config, ufdsClient, function (err, adminUser_) {
                adminUser = adminUser_;
                next(err);
            });
        },

        function (next) {
            ensureKeyInSapi(config, sdcApp, mantaUrl, adminUser,
                function (sErr, key_) {
                    key = key_;
                    next(sErr);
                }
            );
        },

        function (next) {
            ensureKeyOnAdminUser(config, ufdsClient, adminUser, key,
                sdcApp, next);
        },

        function (next) {
            log.info('closing ufdsClient')
            ufdsClient.close(function (err) {
                log.info({err: err}, 'closed ufdsClient')
                next(err);
            })
        }
    ], function (err) {
        if (err) {
            fatal(err, 1);
        }
        log.info('Done.');
    });
}

main();
